'use server';

import { prisma } from '@/lib/prisma';
import { EmissionSource as FrontendEmissionSource, Facility as FrontendFacility } from '@/types';
import { Prisma } from '@prisma/client';

export async function createProject(organizationId: string, name: string, reportingYear: string) {
    try {
        const project = await prisma.project.create({
            data: {
                organizationId,
                name,
                reportingYear,
                status: 'DRAFT',
            },
        });
        return { success: true, data: project };
    } catch (error: any) {
        console.error('Failed to create project:', error);
        return { success: false, error: error.message || 'Failed to create project' };
    }

}

export async function saveProjectData(projectId: string, sources: FrontendEmissionSource[], facilities: FrontendFacility[]) {
    try {
        // Transaction to ensure data consistency
        await prisma.$transaction(async (tx) => {
            // 1. Delete existing data for this project to ensure a clean slate (Sync strategy)
            // Note: Deleting facilities will cascade delete emission sources if configured, 
            // but we explicitly delete sources first to be safe and clear.
            await tx.emissionSource.deleteMany({
                where: { projectId },
            });

            await tx.facility.deleteMany({
                where: { projectId },
            });

            // 2. Create Facilities and map Frontend IDs to Backend IDs
            // We cannot use frontend IDs (like 'default' or 'corporate-level-facility') as DB IDs 
            // because DB IDs must be globally unique UUIDs.
            const idMap = new Map<string, string>();

            for (const facility of facilities) {
                const newFacility = await tx.facility.create({
                    data: {
                        projectId,
                        name: facility.name,
                        equityShare: facility.equityShare,
                        isCorporate: facility.isCorporate || false,
                    },
                });
                idMap.set(facility.id, newFacility.id);
            }

            // Ensure we have at least a fallback facility ID if something goes wrong with mapping
            // (Though if facilities are passed correctly, this shouldn't happen)
            let fallbackFacilityId = '';
            if (idMap.size > 0) {
                fallbackFacilityId = idMap.values().next().value || '';
            } else {
                // If no facilities provided, create a default one
                const defaultFac = await tx.facility.create({
                    data: { projectId, name: 'Default Facility', equityShare: 100, isCorporate: true }
                });
                fallbackFacilityId = defaultFac.id;
            }

            // 3. Create Emission Sources using mapped Facility IDs
            for (const source of sources) {
                const dbFacilityId = idMap.get(source.facilityId) || fallbackFacilityId;

                await tx.emissionSource.create({
                    data: {
                        projectId,
                        facilityId: dbFacilityId,

                        category: source.category,
                        description: source.description,
                        fuelType: source.fuelType,
                        unit: source.unit,
                        monthlyQuantities: source.monthlyQuantities as unknown as Prisma.InputJsonValue,
                        calculationMethod: source.calculationMethod,
                        factor: source.factor,
                        factorUnit: source.factorUnit,
                        factorSource: source.factorSource,
                        transportMode: source.transportMode,
                        vehicleType: source.vehicleType,
                        distanceKm: source.distanceKm,
                        weightTonnes: source.weightTonnes,
                        isAutoGenerated: false,
                    },
                });
            }
        }, {
            maxWait: 5000, // default: 2000
            timeout: 20000, // default: 5000
        });

        return { success: true };
    } catch (error: any) {
        console.error('Failed to save project data:', error);
        return { success: false, error: error.message || 'Failed to save project data' };
    }
}


export async function loadProjectData(projectId: string) {
    try {
        const project = await prisma.project.findUnique({
            where: { id: projectId },
            include: {
                emissionSources: true,
                facilities: true,
            },
        });

        if (!project) {
            return { success: false, error: 'Project not found' };
        }

        return { success: true, data: project };
    } catch (error) {
        console.error('Failed to load project data:', error);
        return { success: false, error: 'Failed to load project data' };
    }
}

// ========================================
// Version Management Functions
// ========================================

const MAX_VERSIONS = 10;

/**
 * Create a version snapshot when manually saving
 */
export async function createProjectVersion(
    projectId: string,
    sources: FrontendEmissionSource[],
    facilities: FrontendFacility[],
    userId?: string,
    versionName?: string
) {
    try {
        // Get the next version number
        const latestVersion = await prisma.projectVersion.findFirst({
            where: { projectId },
            orderBy: { versionNumber: 'desc' },
            select: { versionNumber: true },
        });

        const nextVersionNumber = (latestVersion?.versionNumber || 0) + 1;

        // Create the snapshot
        const dataSnapshot = {
            sources,
            facilities,
            createdAt: new Date().toISOString(),
        };

        // Create the version
        const version = await prisma.projectVersion.create({
            data: {
                projectId,
                versionNumber: nextVersionNumber,
                versionName: versionName || `버전 ${nextVersionNumber}`,
                dataSnapshot: dataSnapshot as unknown as Prisma.InputJsonValue,
                createdBy: userId,
            },
        });

        // Clean up old versions (keep only MAX_VERSIONS)
        const allVersions = await prisma.projectVersion.findMany({
            where: { projectId },
            orderBy: { versionNumber: 'desc' },
            select: { id: true },
        });

        if (allVersions.length > MAX_VERSIONS) {
            const versionsToDelete = allVersions.slice(MAX_VERSIONS);
            await prisma.projectVersion.deleteMany({
                where: {
                    id: { in: versionsToDelete.map((v: { id: string }) => v.id) },
                },
            });
        }

        return { success: true, data: version };
    } catch (error: any) {
        console.error('Failed to create project version:', error);
        return { success: false, error: error.message || 'Failed to create version' };
    }
}

/**
 * Get all versions for a project
 */
export async function getProjectVersions(projectId: string) {
    try {
        const versions = await prisma.projectVersion.findMany({
            where: { projectId },
            orderBy: { versionNumber: 'desc' },
            select: {
                id: true,
                versionNumber: true,
                versionName: true,
                createdAt: true,
                createdBy: true,
            },
        });

        return { success: true, data: versions };
    } catch (error: any) {
        console.error('Failed to get project versions:', error);
        return { success: false, error: error.message || 'Failed to get versions' };
    }
}

/**
 * Get a specific version's data snapshot
 */
export async function getProjectVersionData(versionId: string) {
    try {
        const version = await prisma.projectVersion.findUnique({
            where: { id: versionId },
            select: {
                id: true,
                versionNumber: true,
                versionName: true,
                dataSnapshot: true,
                createdAt: true,
            },
        });

        if (!version) {
            return { success: false, error: 'Version not found' };
        }

        return { success: true, data: version };
    } catch (error: any) {
        console.error('Failed to get version data:', error);
        return { success: false, error: error.message || 'Failed to get version data' };
    }
}

/**
 * Restore a project to a specific version
 */
export async function restoreProjectVersion(projectId: string, versionId: string) {
    try {
        // Get the version data
        const version = await prisma.projectVersion.findUnique({
            where: { id: versionId },
        });

        if (!version || version.projectId !== projectId) {
            return { success: false, error: 'Version not found or does not belong to this project' };
        }

        const snapshot = version.dataSnapshot as unknown as { sources: FrontendEmissionSource[]; facilities: FrontendFacility[] };

        // Use saveProjectData to restore the data
        const result = await saveProjectData(projectId, snapshot.sources, snapshot.facilities);

        return result;
    } catch (error: any) {
        console.error('Failed to restore project version:', error);
        return { success: false, error: error.message || 'Failed to restore version' };
    }
}

