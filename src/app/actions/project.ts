'use server';

import { prisma } from '@/lib/prisma';
import { EmissionSource as FrontendEmissionSource, Facility as FrontendFacility } from '@/types';
import { Prisma } from '@prisma/client';

export async function createProject(organizationId: string, name: string, reportingYear: string) {
    try {
        const project = await prisma.project.create({
            data: {
                organizationId,
                name,
                reportingYear,
                status: 'DRAFT',
            },
        });
        return { success: true, data: project };
    } catch (error: any) {
        console.error('Failed to create project:', error);
        return { success: false, error: error.message || 'Failed to create project' };
    }

}

export async function saveProjectData(projectId: string, sources: FrontendEmissionSource[], facilities: FrontendFacility[]) {
    try {
        // Transaction to ensure data consistency
        await prisma.$transaction(async (tx) => {
            // 1. Delete existing data for this project to ensure a clean slate (Sync strategy)
            // Note: Deleting facilities will cascade delete emission sources if configured, 
            // but we explicitly delete sources first to be safe and clear.
            await tx.emissionSource.deleteMany({
                where: { projectId },
            });

            await tx.facility.deleteMany({
                where: { projectId },
            });

            // 2. Create Facilities and map Frontend IDs to Backend IDs
            // We cannot use frontend IDs (like 'default' or 'corporate-level-facility') as DB IDs 
            // because DB IDs must be globally unique UUIDs.
            const idMap = new Map<string, string>();

            for (const facility of facilities) {
                const newFacility = await tx.facility.create({
                    data: {
                        projectId,
                        name: facility.name,
                        equityShare: facility.equityShare,
                        isCorporate: facility.isCorporate || false,
                    },
                });
                idMap.set(facility.id, newFacility.id);
            }

            // Ensure we have at least a fallback facility ID if something goes wrong with mapping
            // (Though if facilities are passed correctly, this shouldn't happen)
            let fallbackFacilityId = '';
            if (idMap.size > 0) {
                fallbackFacilityId = idMap.values().next().value || '';
            } else {
                // If no facilities provided, create a default one
                const defaultFac = await tx.facility.create({
                    data: { projectId, name: 'Default Facility', equityShare: 100, isCorporate: true }
                });
                fallbackFacilityId = defaultFac.id;
            }

            // 3. Create Emission Sources using mapped Facility IDs
            for (const source of sources) {
                const dbFacilityId = idMap.get(source.facilityId) || fallbackFacilityId;

                await tx.emissionSource.create({
                    data: {
                        projectId,
                        facilityId: dbFacilityId,

                        category: source.category,
                        description: source.description,
                        fuelType: source.fuelType,
                        unit: source.unit,
                        monthlyQuantities: source.monthlyQuantities as unknown as Prisma.InputJsonValue,
                        calculationMethod: source.calculationMethod,
                        factor: source.factor,
                        factorUnit: source.factorUnit,
                        factorSource: source.factorSource,
                        transportMode: source.transportMode,
                        vehicleType: source.vehicleType,
                        distanceKm: source.distanceKm,
                        weightTonnes: source.weightTonnes,
                        isAutoGenerated: false,
                    },
                });
            }
        }, {
            maxWait: 5000, // default: 2000
            timeout: 20000, // default: 5000
        });

        return { success: true };
    } catch (error: any) {
        console.error('Failed to save project data:', error);
        return { success: false, error: error.message || 'Failed to save project data' };
    }
}


export async function loadProjectData(projectId: string) {
    try {
        const project = await prisma.project.findUnique({
            where: { id: projectId },
            include: {
                emissionSources: true,
                facilities: true,
            },
        });

        if (!project) {
            return { success: false, error: 'Project not found' };
        }

        return { success: true, data: project };
    } catch (error) {
        console.error('Failed to load project data:', error);
        return { success: false, error: 'Failed to load project data' };
    }
}
